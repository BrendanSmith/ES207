#read data from file (2 steps)
gdal_grid = readGDAL("rasterfile.tif")
r = raster(gdal_grid) #use data as a projected raster
install.packages("rgdal")
install.packages("raster")
libarary(rgdal)
library(rgdal)
#read data from file (2 steps)
gdal_grid = readGDAL("rasterfile.tif")
r = raster(gdal_grid) #use data as a projected raster
library("readGDAL")
library("rgdal")
library(rgdal)
install.packages("raster")
install.packages(/var/folders/99/zrtspy713wng77qccpks3dzc0000gn/T//RtmpX6QBzN/downloaded_packages/raster_2.5-2.tar.gz, repos = NULL, type="source")
install.packages(var/folders/99/zrtspy713wng77qccpks3dzc0000gn/T//RtmpX6QBzN/downloaded_packages/raster_2.5-2.tar.gz, repos = NULL, type="source")
install.packages(var/folders/99/zrtspy713wng77qccpks3dzc0000gn/T/RtmpX6QBzN/downloaded_packages/raster_2.5-2.tar.gz, repos = NULL, type="source")
install.packages(var/folders/99/zrtspy713wng77qccpks3dzc0000gn/T/RtmpX6QBzN/downloaded_packages/raster_2.5-2.tar, repos = NULL, type="source")
library("rgdal")
library(rgdal)
library(raster)
library(raster)
library(rgdal)
install.packages("rgdal")
install.packages("rgdal")
library(rgdal)
#read data from file (2 steps)
gdal_grid = readGDAL("rasterfile.tif")
r = raster(gdal_grid) #use data as a projected raster
#read data from file (2 steps)
gdal_grid = readGDAL("DEM.tif")
r = raster(gdal_grid) #use data as a projected raster
plot(r)
r
summary(r)
detach gdal_grid
detach(gdal_grid)
rm gdal_grid
?deleteDataset
deleteDataset(gdal_grid)
gdal_grid = readGDAL("DEM.tif")
dem = raster(gdal_grid) #use data as a projected raster
plot(dem)
```
gdal_grid = readGDAL("precip_8.tif")
precip = raster(gdal_grid) #use data as a projected raster
plot(precip)
```{r}
gdal_grid = readGDAL("tmean_8.tif")
tmean = raster(gdal_grid) #use data as a projected raster
plot(tmean)
```
```{r}
# Load libraries
#library(stats)
#library(HH)
# Load Ripdata and place into a dataframe
rip <- read.csv("newripdata_survey.csv",sep = ",",header = TRUE)
rip <- read.csv("riparian_cleaned.csv",sep = ",",header = TRUE)
View(rip)
# Add an object that scales the value of height from meters to centimeters
rip$htcm <- rip$Woody_Height_m*100
ProjLoc <- aggregate(cbind(Longitude,Latitude) ~ ProjCode,data=ripdata, mean)
ProjLoc <- aggregate(cbind(Longitude,Latitude) ~ ProjCode,data=rip, mean)
rip$ProjLoc <- aggregate(cbind(Longitude,Latitude) ~ ProjCode,data=rip, mean)
plot(ProjLoc)
gdal_grid = readGDAL("DEM.tif")
dem = raster(gdal_grid) #use data as a projected raster
plot(dem)
points(ProjLoc)
points(ProjLoc,pch=50)
points(ProjLoc,pch=200)
points(ProjLoc,pch=21:25)
points(ProjLoc,pch=21:25)
points(ProjLoc)
pch=21
points(ProjLoc)
``{r}
# Load libraries
#library(stats)
#library(HH)
# Load Ripdata and place into a dataframe
rip <- read.csv("riparian_cleaned.csv",sep = ",",header = TRUE)
# Add an object that scales the value of height from meters to centimeters
rip$htcm <- rip$Woody_Height_m*100
ProjLoc <- aggregate(cbind(Longitude,Latitude) ~ ProjCode,data=rip, mean)
```
gdal_grid = readGDAL("DEM.tif")
dem = raster(gdal_grid) #use data as a projected raster
plot(dem)
points(ProjLoc,pch=21:25)
require(stats) # for rnorm
plot(-4:4, -4:4, type = "n")  # setting up coord. system
points(rnorm(200), rnorm(200), col = "red")
points(rnorm(100)/2, rnorm(100)/2, col = "blue", cex = 1.5)
op <- par(bg = "light blue")
x <- seq(0, 2*pi, len = 51)
## something "between type='b' and type='o'":
plot(x, sin(x), type = "o", pch = 21, bg = par("bg"), col = "blue", cex = .6,
main = 'plot(..., type="o", pch=21, bg=par("bg"))')
par(op)
## Not run:
## The figure was produced by calls like
png("pch.png", height = 0.7, width = 7, res = 100, units = "in")
par(mar = rep(0,4))
plot(c(-1, 26), 0:1, type = "n", axes = FALSE)
text(0:25, 0.6, 0:25, cex = 0.5)
points(0:25, rep(0.3, 26), pch = 0:25, bg = "grey")
require(stats) # for rnorm
plot(-4:4, -4:4, type = "n")  # setting up coord. system
points(rnorm(200), rnorm(200), col = "red")
points(rnorm(100)/2, rnorm(100)/2, col = "blue", cex = 1.5)
op <- par(bg = "light blue")
x <- seq(0, 2*pi, len = 51)
## something "between type='b' and type='o'":
plot(x, sin(x), type = "o", pch = 21, bg = par("bg"), col = "blue", cex = .6,
main = 'plot(..., type="o", pch=21, bg=par("bg"))')
par(op)
require(stats) # for rnorm
plot(-4:4, -4:4, type = "n")  # setting up coord. system
points(rnorm(200), rnorm(200), col = "red")
points(rnorm(100)/2, rnorm(100)/2, col = "blue", cex = 1.5)
op <- par(bg = "light blue")
x <- seq(0, 2*pi, len = 51)
## something "between type='b' and type='o'":
plot(x, sin(x), type = "o", pch = 21, bg = par("bg"), col = "blue", cex = .6,
main = 'plot(..., type="o", pch=21, bg=par("bg"))')
par(op)
png("pch.png", height = 0.7, width = 7, res = 100, units = "in")
par(mar = rep(0,4))
plot(c(-1, 26), 0:1, type = "n", axes = FALSE)
text(0:25, 0.6, 0:25, cex = 0.5)
points(0:25, rep(0.3, 26), pch = 0:25, bg = "grey")
require(stats) # for rnorm
plot(-4:4, -4:4, type = "n")  # setting up coord. system
points(rnorm(200), rnorm(200), col = "red")
points(rnorm(100)/2, rnorm(100)/2, col = "blue", cex = 1.5)
op <- par(bg = "light blue")
x <- seq(0, 2*pi, len = 51)
## something "between type='b' and type='o'":
plot(x, sin(x), type = "o", pch = 21, bg = par("bg"), col = "blue", cex = .6,
main = 'plot(..., type="o", pch=21, bg=par("bg"))')
par(op)
## Not run:
## The figure was produced by calls like
png("pch.png", height = 0.7, width = 7, res = 100, units = "in")
par(mar = rep(0,4))
plot(c(-1, 26), 0:1, type = "n", axes = FALSE)
text(0:25, 0.6, 0:25, cex = 0.5)
points(0:25, rep(0.3, 26), pch = 0:25, bg = "grey")
points(ProjLoc)
plot(points(ProjLoc))
```{r}
# Load libraries
#library(stats)
#library(HH)
# Load Ripdata and place into a dataframe
rip <- read.csv("riparian_cleaned.csv",sep = ",",header = TRUE)
# Add an object that scales the value of height from meters to centimeters
rip$htcm <- rip$Woody_Height_m*100
ProjLoc <- aggregate(cbind(Longitude,Latitude) ~ ProjCode,data=rip, mean)
# Load the DEM
gdal_grid = readGDAL("DEM.tif")
dem = raster(gdal_grid) #use data as a projected raster
plot(dem)
plot(dem)
---
title: "Homework Assignment 4"
author: "Brendan Smith"
date: "March 3, 2016"
output: pdf_document
---
**Objective Statement:** The prupose of this lab is to determine if the linear models we are developing can adequately characterize the biomass found in the studied habitats. Further, we must compare sites and genera, determining which vary more than others. We are building upon previous labs, and developing a full linear model that relates tree height as a function of DBH and site or genus. A new report will be created that shows the model results for the height as a function of DBH and a factor, being site or genus.
**Methods:** We begin by importing the "cleaned" riparian data frame from the previous homework. We are to first detemine if there is a systematic bias in the heigh variation by site, then to use genus as a desired factor. The systematic bias is studied by creating a summary subset and analyzing.
**Data: ** The data utilized in this lab is taken from the previous two labs. These data are of several genera of trees' diameter at breast height (DBH) and height, which has been reduced to be of only five most common genera found in the original dataset. Additionally, the height was measured in meters and has been scaled to centimeters for data analysis purposes. DBH was measured in centimeters.
**Code:** The new code introduced and used in this assignment are `lapply`, `for` loop, `do.call()`, `with()`, `aov()` and `TukeyHSD()`.
**Results:** We begin our analysis as usual by importing the dataset from the comma separated value file:
```{r}
# Load libraries
library(stats)
library(HH)
# Load Ripdata and place into a dataframe
rip <- read.csv("newripdata_survey.csv",sep = ",",header = TRUE)
# Add an object that scales the value of height from meters to centimeters
rip$htcm <- rip$Woody_Height_m*100
```
We proceed to make necessary adjustments to the dataframe for data manipulation purposes:
```{r}
#Concatenate ProjCode and Plot.Name using the paste() function, typecast as a factor, then place these factors in rip$projplot
rip$projplot <- as.factor(paste(rip$ProjCode,rip$Plot.Name))
#use tapply() to cycle through each project plot and generate stats
#where ‘htcm’ is height in cm
ripsum <- data.frame(cbind(tapply(rip$htcm,rip$projplot,mean),tapply(rip$htcm,rip$projplot,sd),tapply(rip$htcm,rip$projplot,length)))
#add column names
#(height mean, height standard deviation, number of plots)
colnames(ripsum) <- c("htcmmn","htcmsd","plot.n")
#add a projplot column (from row names) to ripsum
ripsum$projplot <- as.factor(rownames(ripsum))
```
```{r}
#subset for plots with more than one measurement
ripsum <- ripsum[ripsum$plot.n > 1,]
#Add a proj column and populate with the first five letters of projplot (the ProjCode) via the substr() function. Then typecast to factor
ripsum$proj <- as.factor(substr(ripsum$projplot,1,5))
```
We compare the `for` loop operation to the list apply (`lapply`) in order to demonstrate that although the functions have similar outcomes, the list apply is more efficient for evaluating an array of values simultaneously.
```{r}
#create list of project sites
projlevels <- levels(ripsum$proj) #compare a ‘for’ loop of summary
for (p in 1:length(projlevels)) print(summary(ripsum[ripsum$proj == projlevels[p],]))
#with a summary using lapply() (known as list apply)
lapply(projlevels, function(x) summary(ripsum[ripsum$proj == x,]))
```
It can be seen that while the outcome is the same, the setup and application of the for loop is somewhat inefficient in that we must manually indicate the start and stop indeces in order to iterate through the entire array/vector individually with the `for` loop, whereas with the list apply, all elements are evaluated by the function automatically.
We then use `lapply` to randomly select six sample plot summaries from each project site. This is done by by first introducing a variable that is set to the integer 6, the number of samples desired. The function `sample` is then used to output the desired number of samples (6) randomly from each project site. To execute this for all project sites, the `lapply` function is utilized. These values are stored and combined by row using the `rbind()` function along with `do.call()`. Finally, the summary is output.
```{r}
nsamples <- 6 #Set the number of samples
ripres <- lapply(projlevels, function(x) ripsum[which(ripsum$proj == x),][sample(nrow(ripsum[which(ripsum$proj == x),]),nsamples),])
# combine samples by row using rbind()
# and by calling ripres lapply function from do.call()
ripsample <- do.call(rbind,ripres)
summary(ripsample$proj)
```
The coefficient of variation (CV) then added to the summary table by calculating the CV by means of the `with()` function. The `with()` function evaluates an `R` expression (second input term) of the input data (first term). In this case, we are evaluating the coefficient of variation, which is the standard deviation divided by the mean. This value is then stored into our dataframe.
```{r}
#calculate CV using with(data,calc)
ripsample$cv <- with(ripsample, htcmsd / htcmmn)
```
Equipped with the coefficient of variation, we can now run a one-way analysis of variation (ANOVA) on the data frame. This is done by utilizing the `aov` function, which we input the CV as a function of the project code. The output is the sum of squares, degrees of freedom and the residual standard error, all of which are stored in a new variable followed by a summary output.
```{r}
rip.proj.cv.aov = aov(cv~proj,data=ripsample)
summary(rip.proj.cv.aov)
#compare it against
summary.lm(rip.proj.cv.aov)
```
The main differences between the summary of the ANOVA results and the summary of the linear model of the ANOVA is that the lm version yields information regarding the individual project sites and the residuals, whereas the summary of the ANOVA yields information regarding all project sites and residuals, limited to DOF, sum of squares, mean squared, F value and probability.
A Tukey test is performed to check for significant differences between sites, and print out the results. We can see from the print out of the Tukey test and the plot that there is not a significant difference between sites.
```{r}
rip.aov.hsd <- TukeyHSD(rip.proj.cv.aov)
rip.aov.hsd
plot(rip.aov.hsd)
```
In step two we are evaluating the analysis of covariance (ANCOVA), in which we are using the height as a funtion of DBH and genus as a factor. We begin by creating a general linear model where the height of the tree is a function of the DBH and a function of genus separately.
```{r}
# Create a linear model for height versus DBH
rip.cov.htdbh <-glm(rip$htcm~rip$Woody_DBH_cm)
# Generate summary for this model
summary(rip.cov.htdbh)
summary.lm(rip.cov.htdbh)
# Create a linear model for height versus Genus
rip.cov.htg <-glm(rip$htcm~rip$Genus)
# Generate summary for this model
summary(rip.cov.htg)
summary.lm(rip.cov.htg)
# Create a linear model for height as a function of DBH and Genus
rip.cov.htdbhg <-glm(rip$htcm~rip$Woody_DBH_cm*rip$Genus)
# Generate summary for this model
summary(rip.cov.htdbhg)
summary.lm(rip.cov.htdbhg)
ancovaplot(rip$htcm~rip$Woody_DBH_cm*rip$Genus,data=rip)
```
The next step would be to generate an `ancovaplot()` for the two model formulations, with an without the interaction; however, the `ancovaplot()` function will always through a "subset" error for this data set for some reason.
```{r}
plot(ripsum)
```
**Discussion:** Through the use of the coefficient of variation, we were able to run a one-way ANOVA, followed by checking for significant differences between sites using the Tukey test. By analyzing the summary and plot of these results, we can see that there is not significant differences in the variation of the height at these project codes. This is to say that height variability does not differ much between project codes. By utilizing the Tukey test, we are analyzing the differences between the means of the levels of the factor created by the one-way ANOVA. We can see that the difference between the means are relatively low, indicating that there is not a significant difference. Furthermore, if we look at the plot generated utilizing the Tukey data, we can see that all the project codes' differences in mean levels fall around zero, reinforcing our notion.
**Limitations:** A limitaiton that was encountered in this homework assignment was the inability to utilize the `ancovaplot()` function. Though the input parameters seemed to be accurate, an error was always thrown.
library(stats)
library(HH)
# Load Ripdata and place into a dataframe
rip <- read.csv("newripdata_survey.csv",sep = ",",header = TRUE)
# Add an object that scales the value of height from meters to centimeters
rip$htcm <- rip$Woody_Height_m*100
```
We proceed to make necessary adjustments to the dataframe for data manipulation purposes:
```{r}
